<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@3.0.1 static/trough/trough.glb --transform --root /trough/ --isolated
Modified: Added white materials with black outlines and node puppeting support
-->

<script lang="ts">
    import { T, useThrelte } from '@threlte/core'
    import { useGltf } from '@threlte/extras'
    import * as THREE from 'three'
    import { Line2 } from 'three/examples/jsm/lines/Line2.js'
    import { LineMaterial } from 'three/examples/jsm/lines/LineMaterial.js'
    import { LineSegmentsGeometry } from 'three/examples/jsm/lines/LineSegmentsGeometry.js'
  
    let { fallback, error, children, mesh1 = $bindable(), mesh2 = $bindable(), mesh3 = $bindable(), group = $bindable() } = $props()
  
    const gltf = useGltf('/trough/trough.glb')
    const { size } = useThrelte()
    
    // Calculate centered position based on bounding box
    let centerOffset: [number, number, number] = $state([0, 0, 0]);
    let line1: Line2 | null = $state(null);
    let line2: Line2 | null = $state(null);
    let line3: Line2 | null = $state(null);
    
    // Create thick lines with LineMaterial
    function createThickLine(geometry: THREE.BufferGeometry) {
        const edgesGeometry = new THREE.EdgesGeometry(geometry, 15);
        const lineSegmentsGeo = new LineSegmentsGeometry();
        
        const positions = edgesGeometry.attributes.position.array;
        lineSegmentsGeo.setPositions(positions);
        
        const lineMaterial = new LineMaterial({
            color: 0x0000ff,
            linewidth: 2, // in pixels
            resolution: new THREE.Vector2($size.width, $size.height),
            depthTest: true,
            depthWrite: false
        });
        
        const line = new Line2(lineSegmentsGeo, lineMaterial);
        line.computeLineDistances();
        
        return line;
    }
    
    $effect(() => {
        gltf.then(gltfData => {
            if (gltfData && gltfData.nodes) {
                const box = new THREE.Box3();
                
                const geometries = [
                    gltfData.nodes.trough_1?.geometry,
                    gltfData.nodes.trough_2?.geometry,
                    gltfData.nodes.trough_3?.geometry
                ].filter(Boolean);
                
                geometries.forEach(geo => {
                    if (geo) {
                        geo.computeBoundingBox();
                        if (geo.boundingBox) {
                            box.union(geo.boundingBox);
                        }
                    }
                });
                
                const center = new THREE.Vector3();
                box.getCenter(center);
                
                // Negate the center to position it at origin
                centerOffset = [-center.x, -center.y, -center.z];
                
                // Create thick lines
                line1 = createThickLine(gltfData.nodes.trough_1.geometry);
                line2 = createThickLine(gltfData.nodes.trough_2.geometry);
                line3 = createThickLine(gltfData.nodes.trough_3.geometry);
            }
        });
    });
    
    // Update line material resolution when size changes
    $effect(() => {
        if (line1?.material) {
            (line1.material as LineMaterial).resolution.set($size.width, $size.height);
        }
        if (line2?.material) {
            (line2.material as LineMaterial).resolution.set($size.width, $size.height);
        }
        if (line3?.material) {
            (line3.material as LineMaterial).resolution.set($size.width, $size.height);
        }
    });
  </script>
  
  <T.Group dispose={false}>
    {#await gltf}
      {@render fallback?.()}
    {:then gltf}
      <T.Group position={centerOffset} bind:ref={group}>
        <!-- Mesh 1 - invisible but writes to depth buffer for occlusion -->
        <T.Mesh
          bind:ref={mesh1}
          geometry={gltf.nodes.trough_1.geometry}
          renderOrder={0}
        >
          <T.MeshBasicMaterial 
            colorWrite={false} 
            depthWrite={true} 
            depthTest={true}
            side={THREE.DoubleSide}
          />
        </T.Mesh>
        {#if line1}
          <T is={line1} renderOrder={1} />
        {/if}
        
        <!-- Mesh 2 - invisible but writes to depth buffer for occlusion -->
        <T.Mesh
          bind:ref={mesh2}
          geometry={gltf.nodes.trough_2.geometry}
          renderOrder={0}
        >
          <T.MeshBasicMaterial 
            colorWrite={false} 
            depthWrite={true} 
            depthTest={true}
            side={THREE.DoubleSide}
          />
        </T.Mesh>
        {#if line2}
          <T is={line2} renderOrder={1} />
        {/if}
        
        <!-- Mesh 3 - invisible but writes to depth buffer for occlusion -->
        <T.Mesh
          bind:ref={mesh3}
          geometry={gltf.nodes.trough_3.geometry}
          renderOrder={0}
        >
          <T.MeshBasicMaterial 
            colorWrite={false} 
            depthWrite={true} 
            depthTest={true}
            side={THREE.DoubleSide}
          />
        </T.Mesh>
        {#if line3}
          <T is={line3} renderOrder={1} />
        {/if}
      </T.Group>
    {:catch err}
      {@render error?.({ error: err })}
    {/await}
  
    {@render children?.()}
  </T.Group>
  